#include "RivalBearIntroCutscene.h"
#include "entities/Boss.h"
#include "entities/RivalBear.h"
#include "core/Camera.h"
#include "systems/TileMap.h"
#include <cmath>
#include <iostream>

RivalBearIntroCutscene::RivalBearIntroCutscene(Boss* boss)
    : boss_(boss), phase_(Phase::PanLeft)
{
}

void RivalBearIntroCutscene::start()
{
    phase_ = Phase::FadeIn;
    
    // Calculate target to center on boss
    if (boss_)
    {
        targetCameraX_ = boss_->getX() - 160.0f;  // Center horizontally (320/2 = 160)
        targetCameraY_ = boss_->getY() - 120.0f;  // Center vertically (240/2 = 120)
        
        // Clamp to world bounds (can't go negative)
        if (targetCameraX_ < 0) targetCameraX_ = 0;
        if (targetCameraY_ < 0) targetCameraY_ = 0;
    }
    
    std::cerr << "[RivalBearIntro] Starting cutscene, target=(" << targetCameraX_ << "," << targetCameraY_ << ")\n";
}

void RivalBearIntroCutscene::update(float dt, Camera& camera, const TileMap& map)
{
    switch (phase_)
    {
        case Phase::FadeIn:
        {
            // Wait for letterbox bars to fade in (0.5 seconds)
            fadeTimer_ += dt;
            if (fadeTimer_ >= 0.5f)
            {
                fadeTimer_ = 0.0f;
                phase_ = Phase::PanLeft;
                std::cerr << "[RivalBearIntro] Fade complete, starting pan left\n";
            }
            break;
        }
        
        case Phase::PanLeft:
        {
            // Pan camera left to center boss horizontally
            float dx = targetCameraX_ - camera.x;
            float dist = std::abs(dx);
            
            if (dist < 1.0f)
            {
                // Reached horizontal target, now pan up
                camera.x = targetCameraX_;
                phase_ = Phase::PanUp;
                std::cerr << "[RivalBearIntro] Pan left complete, starting pan up\n";
            }
            else
            {
                // Move toward target
                float moveAmount = cameraMoveSpeed_ * dt;
                if (moveAmount > dist) moveAmount = dist;
                camera.x += (dx < 0 ? -moveAmount : moveAmount);
                
                if (camera.x < 0) camera.x = 0;
            }
            break;
        }
        
        case Phase::PanUp:
        {
            // Pan camera up to center boss vertically
            float dy = targetCameraY_ - camera.y;
            float dist = std::abs(dy);
            
            if (dist < 1.0f)
            {
                // Panning complete, start boss AI and follow
                camera.y = targetCameraY_;
                if (camera.y < 0) camera.y = 0;
                phase_ = Phase::FollowBoss;
                
                // Start boss intro sequence
                if (boss_ && !boss_->isIntroActive())
                {
                    boss_->startIntro();
                    std::cerr << "[RivalBearIntro] Pan complete, boss jumping\n";
                }
            }
            else
            {
                // Move toward target
                float moveAmount = cameraMoveSpeed_ * dt;
                if (moveAmount > dist) moveAmount = dist;
                camera.y += (dy < 0 ? -moveAmount : moveAmount);
                
                if (camera.y < 0) camera.y = 0;
            }
            break;
        }
        
        case Phase::FollowBoss:
        {
            // Check if boss is ready for camera transition (after growl)
            RivalBear* rivalBear = dynamic_cast<RivalBear*>(boss_);
            if (rivalBear && rivalBear->isReadyForCameraTransition())
            {
                phase_ = Phase::Complete;
                rivalBear->markCutsceneComplete();
                std::cerr << "[RivalBearIntro] Boss ready for camera transition, cutscene complete\n";
            }
            
            // Smoothly follow boss (center camera on boss position)
            if (boss_ && phase_ != Phase::Complete)
            {
                float targetX = boss_->getX() - camera.width / 2;
                float targetY = boss_->getY() - camera.height / 2;
                
                // Smooth following with interpolation
                float followSpeed = 5.0f;  // Higher = tighter following
                camera.x += (targetX - camera.x) * followSpeed * dt;
                camera.y += (targetY - camera.y) * followSpeed * dt;
                
                // Clamp to world bounds
                if (camera.x < 0) camera.x = 0;
                if (camera.y < 0) camera.y = 0;
                if (camera.x > map.width * map.tileSize - camera.width)
                    camera.x = map.width * map.tileSize - camera.width;
                if (camera.y > map.height * map.tileSize - camera.height)
                    camera.y = map.height * map.tileSize - camera.height;
            }
            break;
        }
        
        case Phase::Complete:
            // Do nothing, cutscene is complete
            break;
    }
}

bool RivalBearIntroCutscene::isComplete() const
{
    return phase_ == Phase::Complete;
}
